/**
 * Stock Baseline Manager
 * 
 * Gerencia o ajuste autom√°tico do baseline do lucro empresarial
 * quando h√° modifica√ß√µes manuais no estoque de mat√©ria-prima e produtos de revenda.
 * 
 * REGRA:
 * - ADICIONAR estoque ‚Üí SOMAR valor ao baseline (entrou dinheiro/produto)
 * - REMOVER estoque ‚Üí SUBTRAIR valor do baseline (saiu dinheiro/produto)
 */

import { dataManager } from './dataManager';

export class StockBaselineManager {
  /**
   * Ajusta o baseline ao ADICIONAR estoque
   * @param quantity Quantidade adicionada
   * @param unitCost Custo unit√°rio do item
   * @param itemName Nome do item (para logs)
   */
  static async adjustBaselineOnAdd(
    quantity: number,
    unitCost: number,
    itemName: string = 'Item'
  ): Promise<boolean> {
    try {
      const valueAdded = quantity * unitCost;
      console.log(`üí∞ [StockBaselineManager] ADICIONANDO ao baseline:`, {
        item: itemName,
        quantity,
        unitCost,
        valueAdded: valueAdded.toFixed(2)
      });

      const currentBaseline = await dataManager.loadBusinessValueBaseline();
      
      if (currentBaseline === null) {
        console.log(`‚ö†Ô∏è [StockBaselineManager] Baseline n√£o definido, ajuste n√£o aplicado`);
        return false;
      }

      const newBaseline = currentBaseline + valueAdded;
      const success = await dataManager.saveBusinessValueBaseline(newBaseline);

      if (success) {
        console.log(`‚úÖ [StockBaselineManager] Baseline atualizado!`, {
          previous: currentBaseline.toFixed(2),
          added: valueAdded.toFixed(2),
          new: newBaseline.toFixed(2)
        });
      }

      return success;
    } catch (error) {
      console.error(`‚ùå [StockBaselineManager] Erro ao adicionar ao baseline:`, error);
      return false;
    }
  }

  /**
   * Ajusta o baseline ao REMOVER estoque
   * @param quantity Quantidade removida
   * @param unitCost Custo unit√°rio do item
   * @param itemName Nome do item (para logs)
   */
  static async adjustBaselineOnRemove(
    quantity: number,
    unitCost: number,
    itemName: string = 'Item'
  ): Promise<boolean> {
    try {
      const valueRemoved = quantity * unitCost;
      console.log(`üí∞ [StockBaselineManager] SUBTRAINDO do baseline:`, {
        item: itemName,
        quantity,
        unitCost,
        valueRemoved: valueRemoved.toFixed(2)
      });

      const currentBaseline = await dataManager.loadBusinessValueBaseline();
      
      if (currentBaseline === null) {
        console.log(`‚ö†Ô∏è [StockBaselineManager] Baseline n√£o definido, ajuste n√£o aplicado`);
        return false;
      }

      const newBaseline = currentBaseline - valueRemoved;
      const success = await dataManager.saveBusinessValueBaseline(newBaseline);

      if (success) {
        console.log(`‚úÖ [StockBaselineManager] Baseline atualizado!`, {
          previous: currentBaseline.toFixed(2),
          removed: valueRemoved.toFixed(2),
          new: newBaseline.toFixed(2)
        });
      }

      return success;
    } catch (error) {
      console.error(`‚ùå [StockBaselineManager] Erro ao subtrair do baseline:`, error);
      return false;
    }
  }

  /**
   * Verifica se o baseline est√° definido
   */
  static async isBaselineDefined(): Promise<boolean> {
    try {
      const baseline = await dataManager.loadBusinessValueBaseline();
      return baseline !== null;
    } catch (error) {
      console.error(`‚ùå [StockBaselineManager] Erro ao verificar baseline:`, error);
      return false;
    }
  }

  /**
   * Obt√©m informa√ß√µes do baseline atual
   */
  static async getBaselineInfo(): Promise<{
    baseline: number | null;
    isDefined: boolean;
  }> {
    try {
      const baseline = await dataManager.loadBusinessValueBaseline();
      return {
        baseline,
        isDefined: baseline !== null
      };
    } catch (error) {
      console.error(`‚ùå [StockBaselineManager] Erro ao obter info do baseline:`, error);
      return {
        baseline: null,
        isDefined: false
      };
    }
  }
}
