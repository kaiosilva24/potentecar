import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, XCircle, AlertTriangle, RefreshCw } from "lucide-react";
import {
  initializeDefaultTireCosts,
  ensureTireCostExists,
  hasSpecificTireCost,
  clearDefaultTireCosts,
  DEFAULT_TIRE_COSTS,
} from "@/utils/defaultTireCosts";

interface TestResult {
  productName: string;
  hasData: boolean;
  cost: number;
  source: string;
}

const TireCostFixTest: React.FC = () => {
  const [testResults, setTestResults] = useState<TestResult[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [lastTest, setLastTest] = useState<Date | null>(null);

  // Produtos problem√°ticos identificados nos testes
  const problematicProducts = [
    "165 70 13", // Principal problema identificado
    "205 55 16",
    "195 55 16",
    "175 70 14",
  ];

  const runTest = async () => {
    setIsLoading(true);
    console.log("üß™ [TireCostFixTest] Iniciando teste de corre√ß√£o...");

    const results: TestResult[] = [];

    for (const productName of problematicProducts) {
      console.log(`üîç [TireCostFixTest] Testando produto: ${productName}`);

      // SEMPRE for√ßar inicializa√ß√£o primeiro
      console.log(
        `üîß [TireCostFixTest] For√ßando inicializa√ß√£o para: ${productName}`
      );
      const cost = ensureTireCostExists(productName);

      // Verificar se foi inicializado corretamente
      const productKey = `tireAnalysis_${productName.toLowerCase().replace(/\s+/g, "_")}`;
      const savedData = localStorage.getItem(productKey);
      const data = savedData ? JSON.parse(savedData) : null;

      console.log(`üîç [TireCostFixTest] Resultado para ${productName}:`, {
        productKey,
        cost,
        savedData: !!savedData,
        parsedData: data,
      });

      results.push({
        productName,
        hasData: cost > 0 && !!savedData,
        cost: cost || data?.costPerTire || 0,
        source: data?.source || (cost > 0 ? "ensureTireCostExists" : "failed"),
      });
    }

    setTestResults(results);
    setLastTest(new Date());
    setIsLoading(false);

    // Log do resultado
    const successCount = results.filter((r) => r.hasData).length;
    console.log(
      `üéØ [TireCostFixTest] Teste conclu√≠do: ${successCount}/${results.length} produtos com dados`
    );
  };

  const clearAllData = () => {
    console.log("üßπ [TireCostFixTest] Limpando todos os dados padr√£o...");
    clearDefaultTireCosts();
    setTestResults([]);
    setLastTest(null);
  };

  const initializeAll = async () => {
    setIsLoading(true);
    console.log("üîß [TireCostFixTest] Inicializando todos os custos padr√£o...");

    try {
      // Limpar dados existentes primeiro
      console.log("üßΩ [TireCostFixTest] Limpando dados existentes...");
      clearDefaultTireCosts();

      // Aguardar um pouco
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Inicializar novamente
      console.log("üîß [TireCostFixTest] Inicializando custos padr√£o...");
      await initializeDefaultTireCosts();

      // For√ßar inicializa√ß√£o individual para produtos problem√°ticos
      console.log("üîß [TireCostFixTest] For√ßando inicializa√ß√£o individual...");
      problematicProducts.forEach((productName) => {
        const cost = ensureTireCostExists(productName);
        console.log(`‚úÖ [TireCostFixTest] ${productName}: R$ ${cost}`);
      });

      console.log("‚úÖ [TireCostFixTest] Inicializa√ß√£o conclu√≠da");
      await runTest(); // Re-executar teste ap√≥s inicializa√ß√£o
    } catch (error) {
      console.error("‚ùå [TireCostFixTest] Erro na inicializa√ß√£o:", error);
      setIsLoading(false);
    }
  };

  useEffect(() => {
    // Executar teste inicial
    runTest();
  }, []);

  const getStatusIcon = (result: TestResult) => {
    if (result.hasData && result.cost > 0) {
      return <CheckCircle className="h-5 w-5 text-green-500" />;
    } else if (result.hasData && result.cost === 0) {
      return <AlertTriangle className="h-5 w-5 text-yellow-500" />;
    } else {
      return <XCircle className="h-5 w-5 text-red-500" />;
    }
  };

  const getStatusText = (result: TestResult) => {
    if (result.hasData && result.cost > 0) {
      return "OK";
    } else if (result.hasData && result.cost === 0) {
      return "DADOS INV√ÅLIDOS";
    } else {
      return "SEM DADOS";
    }
  };

  const successCount = testResults.filter(
    (r) => r.hasData && r.cost > 0
  ).length;
  const totalCount = testResults.length;

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          üß™ Teste de Corre√ß√£o - Custos de Pneus
          {isLoading && <RefreshCw className="h-4 w-4 animate-spin" />}
        </CardTitle>
        {lastTest && (
          <p className="text-sm text-muted-foreground">
            √öltimo teste: {lastTest.toLocaleTimeString()}
          </p>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Status Geral */}
        <div className="flex items-center justify-between p-4 bg-muted rounded-lg">
          <div>
            <h3 className="font-semibold">Status Geral</h3>
            <p className="text-sm text-muted-foreground">
              {successCount} de {totalCount} produtos com dados v√°lidos
            </p>
          </div>
          <Badge
            variant={successCount === totalCount ? "default" : "destructive"}
            className="text-lg px-3 py-1"
          >
            {totalCount > 0 ? Math.round((successCount / totalCount) * 100) : 0}
            %
          </Badge>
        </div>

        {/* Controles */}
        <div className="flex gap-2 flex-wrap">
          <Button onClick={runTest} disabled={isLoading} variant="outline">
            üîÑ Re-testar
          </Button>
          <Button
            onClick={initializeAll}
            disabled={isLoading}
            variant="default"
          >
            üîß Limpar e Reinicializar
          </Button>
          <Button
            onClick={clearAllData}
            disabled={isLoading}
            variant="destructive"
          >
            üßπ Limpar Dados
          </Button>
        </div>

        {/* Resultados dos Testes */}
        <div className="space-y-2">
          <h3 className="font-semibold">Resultados por Produto:</h3>
          {testResults.map((result, index) => (
            <div
              key={index}
              className="flex items-center justify-between p-3 border rounded-lg"
            >
              <div className="flex items-center gap-3">
                {getStatusIcon(result)}
                <div>
                  <p className="font-medium">{result.productName}</p>
                  <p className="text-sm text-muted-foreground">
                    Fonte: {result.source}
                  </p>
                </div>
              </div>
              <div className="text-right">
                <Badge
                  variant={
                    result.hasData && result.cost > 0
                      ? "default"
                      : "destructive"
                  }
                >
                  {getStatusText(result)}
                </Badge>
                {result.cost > 0 && (
                  <p className="text-sm text-muted-foreground mt-1">
                    R$ {result.cost.toFixed(2)}
                  </p>
                )}
              </div>
            </div>
          ))}
        </div>

        {/* Informa√ß√µes Adicionais */}
        <div className="mt-4 p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
          <h4 className="font-semibold text-blue-900 dark:text-blue-100">
            ‚ÑπÔ∏è Informa√ß√µes da Corre√ß√£o
          </h4>
          <ul className="text-sm text-blue-800 dark:text-blue-200 mt-2 space-y-1">
            <li>
              ‚Ä¢ Fun√ß√£o s√≠ncrona <code>ensureTireCostExists()</code> implementada
            </li>
            <li>‚Ä¢ Inicializa√ß√£o ass√≠ncrona no dashboard principal</li>
            <li>‚Ä¢ Fallback autom√°tico para custos m√©dios</li>
            <li>‚Ä¢ {DEFAULT_TIRE_COSTS.length} produtos padr√£o dispon√≠veis</li>
            <li>‚Ä¢ Teste for√ßa inicializa√ß√£o individual para cada produto</li>
            <li>
              ‚Ä¢ Chave localStorage: <code>tireAnalysis_165_70_13</code>
            </li>
          </ul>
        </div>
      </CardContent>
    </Card>
  );
};

export default TireCostFixTest;
